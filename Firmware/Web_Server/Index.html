<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Tercio Labs Multi-Motor IMU Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #0b0b0e;
      --fg: #e5e7eb;
      --card: #121217;
      --card2: #0f1117;
      --border: #262632;
      --muted: #9ca3af;
      --accent: #10b981;
      --accent-2: #60a5fa;
      --warn: #f59e0b;
      --danger: #ef4444;
      --purple: #8b5cf6;
      --switch-bg: #1f2937;
      --switch-on: #10b981;
      --switch-knob: #fff;
      --field-bg: #1b1f2a;
      --field-border: #2e3347;
      --btn-secondary-bg: #1f2937;
      --btn-secondary-fg: #e5e7eb;
      --row-bg: #0e111a;
      --log-bg: #000;
      --badge-bg: rgba(255, 255, 255, 0.06);
      --badge-fg: #e5e7eb;
    }

    /* THEME: DARK */
    :root[data-theme="dark"] {
      --bg: #0b0b0e;
      --fg: #e5e7eb;
      --card: #121217;
      --card2: #0f1117;
      --border: #262632;
      --muted: #9ca3af;
      --accent: #10b981;
      --accent-2: #60a5fa;
      --warn: #f59e0b;
      --danger: #ef4444;
      --field-bg: #1b1f2a;
      --field-border: #2e3347;
      --btn-secondary-bg: #1f2937;
      --btn-secondary-fg: #e5e7eb;
      --row-bg: #0e111a;
      --log-bg: #000;
      --badge-bg: rgba(255, 255, 255, 0.06);
      --badge-fg: #e5e7eb;
      --switch-bg: #1f2937;
      --switch-on: #10b981;
      --switch-knob: #fff;
    }

    /* THEME: LIGHT */
    :root[data-theme="light"] {
      --bg: #f7f8fc;
      --fg: #0f172a;
      --card: #ffffff;
      --card2: #f5f7fb;
      --border: #d7deea;
      --muted: #64748b;
      --accent: #059669;
      --accent-2: #2563eb;
      --warn: #d97706;
      --danger: #dc2626;
      --field-bg: #f3f6fb;
      --field-border: #d7deea;
      --btn-secondary-bg: #eef2f7;
      --btn-secondary-fg: #0f172a;
      --row-bg: #ffffff;
      --log-bg: #111;
      --badge-bg: rgba(15, 23, 42, 0.06);
      --badge-fg: #0f172a;
      --switch-bg: #e5e7eb;
      --switch-on: #059669;
      --switch-knob: #fff;
    }

    @media (prefers-color-scheme: light) {
      :root[data-theme="auto"] {
        color-scheme: light;
      }
    }

    @media (prefers-color-scheme: dark) {
      :root[data-theme="auto"] {
        color-scheme: dark;
      }
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      max-width: 100%;
      overflow-x: hidden;
    }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 24px;
    }

    h2 {
      margin: 0 0 8px 0;
    }

    small {
      color: var(--muted);
    }

    .app {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 16px;
    }

    @media (max-width:1024px) {
      .app {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: linear-gradient(180deg, var(--card), var(--card2));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
    }

    .toolbar {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .btn {
      background: var(--accent);
      border: 0;
      color: #08221a;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn.secondary {
      background: var(--btn-secondary-bg);
      color: var(--btn-secondary-fg);
    }

    .btn.info {
      background: var(--accent-2);
      color: #081422;
    }

    .btn.warn {
      background: var(--warn);
      color: #1b1405;
    }

    .btn.danger {
      background: var(--danger);
      color: #2b0b0b;
    }

    .btn.magic {
      background: var(--purple);
      color: #fff;
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    input,
    select,
    textarea {
      background: var(--field-bg);
      border: 1px solid var(--field-border);
      color: var(--fg);
      border-radius: 10px;
      padding: 12px 14px;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Consolas, Monaco, monospace;
    }

    .split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    @media (max-width:1024px) {
      .split {
        grid-template-columns: 1fr;
      }
    }

    .pill {
      background: var(--badge-bg);
      color: var(--badge-fg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 10px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
    }

    .warnbar {
      background: #2a1111;
      border: 1px solid #6b1d1d;
      color: #ffd2d2;
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 8px;
    }

    .warnbar.stall {
      background: #451a1a;
      border-color: #ef4444;
      color: #fca5a5;
      font-weight: bold;
    }

    .hidden {
      display: none !important;
    }

    /* Devices header layout */
    .dev-header2 {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 12px;
    }

    .dev-header2 .title {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .dev-header2 .title h2 {
      margin: 0;
    }

    .dev-header2 .title .sub {
      color: var(--muted);
      font-size: 14px;
      line-height: 1.2;
    }

    .dev-header2 .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    @media (max-width:700px) {
      .dev-header2 {
        flex-direction: column;
        align-items: stretch;
      }

      .dev-header2 .controls {
        flex-wrap: wrap;
      }
    }

    .search {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .dev-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 60vh;
      overflow: auto;
    }

    .dev-item {
      border: 1px solid var(--border);
      background: var(--row-bg);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      align-items: center;
      cursor: pointer;
    }

    .dev-item.active {
      outline: 2px solid var(--accent);
    }

    .dev-item.stalled {
      outline: 2px solid var(--danger);
    }

    .dev-item:focus {
      outline: 2px solid var(--accent-2);
    }

    .dev-tags {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .tag {
      font-size: 11px;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--badge-bg);
      color: var(--badge-fg);
    }

    .tag.warn {
      border-color: #6b1d1d;
      background: #2a1111;
      color: #ffd2d2;
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      gap: 10px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    #log {
      background: var(--log-bg);
      border: 1px solid var(--border);
      border-radius: 14px;
      height: 36vh;
      overflow: auto;
      padding: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      user-select: none;
      cursor: pointer;
    }

    .toggle input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .switch {
      width: 46px;
      height: 26px;
      background: var(--switch-bg);
      border: 1px solid var(--field-border);
      border-radius: 999px;
      position: relative;
      transition: .2s;
    }

    .knob {
      width: 22px;
      height: 22px;
      background: #fff;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 2px;
      transform: translateY(-50%);
      transition: left .2s;
    }

    .toggle input:checked+.switch {
      background: var(--switch-on);
      border-color: transparent;
    }

    .toggle input:checked+.switch .knob {
      left: 22px;
    }

    /* Disabled state visual for toggles */
    .gated input:disabled+.switch {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .gated input:disabled+.switch+span {
      opacity: 0.5;
    }

    /* TABLE FIXES */
    .table-container {
      width: 100%;
      overflow-x: auto;
      /* Enable horizontal scroll */
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--row-bg);
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      min-width: 800px;
      /* Force width */
    }

    td,
    th {
      font-size: 13px;
      text-align: left;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
      /* Prevent wrap */
    }

    th {
      background: var(--card2);
      font-weight: 600;
      color: var(--muted);
    }

    tr:last-child td {
      border-bottom: 0;
    }

    tr:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    label:not(.toggle) {
      display: block !important;
      margin: 0 0 16px !important;
    }

    label:not(.toggle) input,
    label:not(.toggle) select,
    label:not(.toggle) textarea {
      display: block;
      width: 100%;
      margin-top: 12px !important;
    }

    .label-inline {
      display: inline;
    }

    .brand-header {
      text-align: center;
      padding: 16px 0 20px 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 20px;
      background: linear-gradient(180deg, var(--card), var(--card2));
      border-radius: 0 0 20px 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    .brand-header h1 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: 0.5px;
      color: var(--fg);
    }

    /* New Theme Button */
    .theme-btn {
      position: absolute;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background: transparent;
      border: 1px solid var(--border);
      color: var(--muted);
      width: 36px;
      height: 36px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .theme-btn:hover {
      color: var(--fg);
      background: var(--badge-bg);
    }

    .theme-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    /* IMU 3D Visualization */
    .imu-scene {
      width: 200px;
      height: 160px;
      perspective: 800px;
      margin: 20px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .cube {
      width: 0;
      height: 0;
      position: absolute;
      top: 50%;
      left: 50%;
      transform-style: preserve-3d;
    }

    .cube-face {
      position: absolute;
      box-sizing: border-box;
      background: #1f2937;
      border: 1px solid #4b5563;
      backface-visibility: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
      font-size: 10px;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    /* Top/Bottom: 120x120 */
    .face-top,
    .face-bottom {
      width: 120px;
      height: 120px;
      margin: -60px 0 0 -60px;
    }

    /* Sides: 120x20 */
    .face-front,
    .face-back,
    .face-left,
    .face-right {
      width: 120px;
      height: 20px;
      margin: -10px 0 0 -60px;
    }

    .face-top {
      transform: rotateX(90deg) translateZ(10px);
      background: #111827;
      border: 1px solid var(--accent);
    }

    .face-bottom {
      transform: rotateX(-90deg) translateZ(10px);
      background: #000;
    }

    .face-front {
      transform: translateZ(60px);
      background: #374151;
    }

    .face-back {
      transform: rotateY(180deg) translateZ(60px);
      background: #374151;
    }

    .face-right {
      transform: rotateY(90deg) translateZ(60px);
      background: #374151;
    }

    .face-left {
      transform: rotateY(-90deg) translateZ(60px);
      background: #374151;
    }

    .face-top::after {
      content: "▲";
      font-size: 40px;
      color: var(--accent);
      opacity: 0.8;
    }

    /* AXIS GIZMO */
    .axis {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      pointer-events: none;
    }

    .axis-x {
      width: 150px;
      height: 2px;
      background: #ef4444;
      transform: rotateY(0deg);
    }

    .axis-x::after {
      content: "X";
      color: #ef4444;
      position: absolute;
      right: -15px;
      top: -7px;
      font-weight: bold;
      font-size: 12px;
    }

    .axis-y {
      width: 150px;
      height: 2px;
      background: #10b981;
      transform: rotateY(-90deg);
    }

    .axis-y::after {
      content: "Y";
      color: #10b981;
      position: absolute;
      right: -15px;
      top: -7px;
      font-weight: bold;
      font-size: 12px;
    }

    .axis-z {
      width: 100px;
      height: 2px;
      background: #3b82f6;
      transform: rotateZ(-90deg);
    }

    .axis-z::after {
      content: "Z";
      color: #3b82f6;
      position: absolute;
      right: -15px;
      top: -7px;
      font-weight: bold;
      font-size: 12px;
    }

    .imu-stat-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
      margin-top: 20px;
    }

    .imu-stat-box {
      background: var(--badge-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
    }

    .imu-stat-box div:first-child {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 4px;
    }

    .imu-stat-box div:last-child {
      font-family: monospace;
      font-weight: bold;
      font-size: 14px;
    }

    /* HOMING MODE CARD */
    .seg {
      display: inline-flex;
      border: 1px solid var(--field-border);
      background: var(--field-bg);
      border-radius: 12px;
      overflow: hidden;
      width: 100%;
    }

    .seg button {
      flex: 1;
      padding: 10px 10px;
      border: 0;
      background: transparent;
      color: var(--fg);
      cursor: pointer;
      font-weight: 700;
      opacity: 0.85;
    }

    .seg button.active {
      background: rgba(96, 165, 250, 0.18);
      color: var(--fg);
      opacity: 1;
    }

    .seg-hint {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.25;
    }

    .inline-warn {
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #6b1d1d;
      background: #2a1111;
      color: #ffd2d2;
      font-size: 12px;
    }
  </style>
</head>

<body>

  <header class="brand-header">
    <h1>Tercio Labs <span>Web Control UI</span></h1>
    <button id="btnTheme" class="theme-btn" title="Toggle Theme">
      <!-- Icon updated by JS -->
      <svg viewBox="0 0 24 24">
        <path
          d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z" />
      </svg>
    </button>
  </header>

  <div class="app">
    <div class="card">
      <div class="dev-header2">
        <div class="title">
          <h2>Devices</h2>
          <span class="sub">Auto-discovered from telemetry</span>
        </div>
        <div class="controls">
          <button id="btnConnect" class="btn">Connect</button>
        </div>
      </div>
      <div class="search">
        <input id="devSearch" placeholder="Filter by ID/status" class="mono" style="flex:1">
        <button id="btnRefreshDevices" class="btn secondary">Refresh Devices</button>
        <button id="btnExport" class="btn secondary">Export CSV</button>
      </div>
      <div id="devList" class="dev-list" style="margin-top:10px"></div>
    </div>

    <div class="card">
      <div class="section-title">
        <div class="row">
          <h2>Control</h2>
          <div id="status" class="pill"><small>Idle</small></div>
        </div>
        <div class="row">
          <div class="pill"><b>Active</b> <span id="activeId" class="mono"></span></div>
          <div id="imuTag" class="pill hidden" style="background:var(--purple); color:#fff">IMU</div>
          <div id="motorUnitsTag" class="pill"><b>Units</b> <span id="activeUnits" class="mono">rad</span></div>
        </div>
      </div>

      <div id="stallWarn" class="warnbar stall hidden">
        <span><b>MOTOR STALLED!</b> Send a new target angle or use Auto-Tune to recover.</span>
      </div>

      <div id="calibWarn" class="warnbar hidden">
        <b> Not calibrated.</b> Run <i>Do Calibrate</i> on this device.
      </div>

      <div class="split" style="margin-top:10px">
        <!-- IMU CONTROLS -->
        <div class="card">
          <div id="imuControls" class="hidden">
            <div class="section-title">
              <h3 style="margin:0;font-size:16px">IMU Orientation</h3>
              <button id="btnImuZero" class="btn info" style="padding:4px 8px; font-size:12px">Zero Orientation</button>
            </div>

            <div class="imu-scene">
              <div class="cube" id="imuCube">
                <div class="cube-face face-front"></div>
                <div class="cube-face face-back"></div>
                <div class="cube-face face-right"></div>
                <div class="cube-face face-left"></div>
                <div class="cube-face face-top"></div>
                <div class="cube-face face-bottom"></div>
                <div class="axis axis-x"></div>
                <div class="axis axis-y"></div>
                <div class="axis axis-z"></div>
              </div>
            </div>

            <div class="imu-stat-grid">
              <div class="imu-stat-box">
                <div>Roll</div>
                <div id="valRoll">0.00</div>
              </div>
              <div class="imu-stat-box">
                <div>Pitch</div>
                <div id="valPitch">0.00</div>
              </div>
              <div class="imu-stat-box">
                <div>Yaw</div>
                <div id="valYaw">0.00</div>
              </div>
              <div class="imu-stat-box">
                <div>Acc X</div>
                <div id="valAx">0.00</div>
              </div>
              <div class="imu-stat-box">
                <div>Acc Y</div>
                <div id="valAy">0.00</div>
              </div>
              <div class="imu-stat-box">
                <div>Acc Z</div>
                <div id="valAz">0.00</div>
              </div>
            </div>
          </div>

          <!-- MOTOR CONTROLS -->
          <div id="motorControls">
            <div class="section-title">
              <h3 style="margin:0;font-size:16px">Quick Target</h3>
              <div class="pill"><b>Preview:</b> <span id="preview" class="mono"></span></div>
            </div>
            <div class="grid">
              <label><span class="label-inline">Target (<span id="targetUnits">rad</span>)</span>
                <input type="number" id="inTarget" step="0.001" value="0.5"></label>

              <label>Speed limit (rps)<input type="number" id="inRps" step="0.01" value="25.0"></label>
              <label>Accel limit (rps²)<input type="number" id="inRps2" step="0.1" value="150.0"></label>
              <label>Current (mA)<input type="number" id="inmA" step="1" value="1200"></label>
            </div>
            <div class="toolbar" style="margin-top:8px">
              <button id="btnSendTarget" class="btn info gated">Send Target</button>
              <button id="btnSendLimits" class="btn secondary gated">Send Limits</button>
              <button id="btnSetCurrent" class="btn secondary gated">Set Current</button>
              <button id="btnCal" class="btn warn gated">Do Calibrate</button>
              <label class="toggle gated"><input id="tglEnable" type="checkbox"><span class="switch"><span
                    class="knob"></span></span><span>Enable Motor</span></label>
            </div>

            <div class="toolbar" style="margin-top:8px">
              <button id="btn0" class="btn secondary gated">0</button>
              <button id="btn90" class="btn secondary gated">90 (π/2)</button>
              <button id="btn180" class="btn secondary gated">180 (π)</button>
            </div>

            <div class="section-title" style="margin-top:20px; border-top:1px solid var--border; padding-top:10px">
              <h3 style="margin:0;font-size:16px">Auto Tuning</h3>
              <div class="pill"><small>Finds Max Speed</small></div>
            </div>
            <div class="grid">
              <label>Min Angle (deg)<input type="number" id="inTuneMin" value="-500"></label>
              <label>Max Angle (deg)<input type="number" id="inTuneMax" value="500"></label>
            </div>
            <div class="toolbar" style="margin-top:8px">
              <button id="btnAutoTune" class="btn magic gated">Start Auto-Tune</button>
            </div>
            <div class="hint" style="margin-top:10px">Frames: <span class="mono">ID:LO ID:HI CMD LEN PAYLOAD...</span>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="section-title">
            <h3 style="margin:0;font-size:16px">Device Setup</h3>
          </div>
          <div class="grid">
            <label>Change ID<input id="newId" type="number" min="0" max="2047" value="2"></label>
            <div class="motor-specific"><label>Microsteps<input id="ms" type="number" min="1" value="16"></label></div>
            <div class="motor-specific"><label>Steps/Rev<input id="spr" type="number" min="1" value="200"></label></div>
          </div>
          <div class="toolbar" style="margin-top:8px">
            <button id="btnApplyID" class="btn danger gated">Set ID</button>
            <button id="btnApplyStepper" class="btn secondary gated motor-specific">Apply Stepper Params</button>
          </div>

          <div class="section-title motor-specific" style="margin-top:12px">
            <h3 style="margin:0;font-size:16px">Modes & Flags</h3>
          </div>
          <div class="toolbar motor-specific" style="flex-wrap:wrap">
            <label class="toggle gated"><input id="tglUnitsDeg" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>Use Degrees</span></label>
            <label class="toggle gated"><input id="tglStealth" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>StealthChop</span></label>
            <label class="toggle gated"><input id="tglExtEnc" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>External Encoder</span></label>
            <label class="toggle gated"><input id="tglExtMode" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>External Mode</span></label>
            <label class="toggle gated"><input id="tglEndstop" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>Endstop</span></label>
            <label class="toggle gated"><input id="tglEncInvert" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>Encoder Invert</span></label>
            <label class="toggle gated"><input id="tglDirInvert" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>Direction Invert</span></label>
            <label class="toggle gated"><input id="tglLimitActiveLow" type="checkbox"><span class="switch"><span
                  class="knob"></span></span><span>Limit Sw. Active Low</span></label>
          </div>

          <div class="section-title motor-specific" style="margin-top:12px">
            <h3 style="margin:0;font-size:16px">PID</h3>
          </div>
          <div class="grid motor-specific">
            <label>Kp<input id="pidKp" type="number" step="0.001" value="3.0"></label>
            <label>Ki<input id="pidKi" type="number" step="0.001" value="0.0"></label>
            <label>Kd<input id="pidKd" type="number" step="0.001" value="0.0"></label>
          </div>
          <div class="toolbar motor-specific" style="margin-top:8px">
            <button id="btnApplyPID" class="btn secondary gated">Apply PID</button>
          </div>

          <div class="section-title motor-specific" style="margin-top:12px">
            <h3 style="margin:0;font-size:16px">Homing</h3>
          </div>
          <div>
            <!-- HOMING UX UPDATE -->
            <div class="grid motor-specific">
              <label>Method
                <div class="seg" role="tablist" aria-label="Homing mode">
                  <button id="homeModeLimit" type="button" class="active" aria-selected="true">Endstop</button>
                  <button id="homeModeSensorless" type="button" aria-selected="false">Sensorless</button>
                </div>
                <div class="seg-hint" id="homeModeHint">
                  Uses MIN/MAX endstop inputs. Configure <i>Active Low</i> in Modes & Flags.
                </div>
              </label>

              <label>Offset (rad)<input id="homeOffset" type="number" step="0.001" value="0.0"></label>
              <label>Speed (rps)<input id="homeSpeed" type="number" step="0.01" value="15.0"></label>

              <!-- NEW homing current -->
              <label id="homeCurrentWrap">Homing Current (mA)
                <input id="homeCurrent" type="number" step="1" min="0" value="800">
                <div class="seg-hint">Used only for sensorless (stall-based) homing. Start low.</div>
              </label>
            </div>

            <div class="toolbar motor-specific" style="flex-wrap:wrap">
              <label class="toggle gated" id="homeUseMinWrap"><input id="homeUseMin" type="checkbox" checked><span
                  class="switch"><span class="knob"></span></span><span>Seek to MIN</span></label>
              <!-- Direction used by wire struct regardless -->
              <label class="toggle gated"><input id="homeDirPlus" type="checkbox" checked><span class="switch"><span
                    class="knob"></span></span><span>Dir (+)</span></label>

              <button id="btnDoHome" class="btn warn gated">Do Homing</button>
            </div>
          </div>

          <div class="section-title" style="margin-top:14px">
            <h3 style="margin:0;font-size:16px">Bulk ID Tools</h3>
          </div>
          <div class="row">
            <label>Start ID <input id="bulkStart" type="number" min="0" max="2047" value="1"
                style="width:110px"></label>
            <button id="btnSequential" class="btn warn">Assign Sequential IDs</button>
            <button id="btnRefreshList" class="btn secondary">Refresh List</button>
          </div>

        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="section-title">
        <h3 style="margin:0;font-size:16px">Live Telemetry</h3>
      </div>
      <div class="row">
        <div class="pill"><b>Speed:</b> <span id="tlmSpeed" class="mono"></span></div>
        <div class="pill"><b>Angle:</b> <span id="tlmAngle" class="mono"></span></div>
        <div class="pill"><b>Temp:</b> <span id="tlmTemp" class="mono"></span></div>
        <div class="pill"><b>Stalled:</b> <span id="tlmStalled" class="mono"></span></div>
        <div class="pill"><b>Tune:</b> <span id="tlmTune" class="mono"></span></div>
        <div class="pill"><b>Min:</b> <span id="tlmMin" class="mono"></span></div>
        <div class="pill"><b>Max:</b> <span id="tlmMax" class="mono"></span></div>
        <div class="pill"><b>Cal:</b> <span id="tlmCal" class="mono"></span></div>
      </div>
      <div class="table-container" style="margin-top: 12px;">
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>Units</th>
              <th>Speed/Roll</th>
              <th>Angle/Pitch</th>
              <th>Temp/Yaw</th>
              <th>Stalled</th>
              <th>Tune</th>
              <th>Min</th>
              <th>Max</th>
              <th>Cal</th>
              <th>Last seen</th>
            </tr>
          </thead>
          <tbody id="tblBodies"></tbody>
        </table>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="section-title">
        <h3 style="margin:0;font-size:16px">IO Log</h3>
        <div class="toolbar">
          <button id="btnClear" class="btn secondary">Clear</button>
          <button id="btnSave" class="btn secondary">Save</button>
        </div>
      </div>
      <div id="log"></div>
    </div>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    const clamp11 = n => Math.max(0, Math.min(0x7FF, n | 0));
    const hex2 = b => b.toString(16).toUpperCase().padStart(2, '0');
    const bytesHex = u8 => Array.from(u8).map(hex2).join(' ');
    // Floats
    const u8 = v => new Uint8Array([v & 0xFF]);
    const u16le = v => new Uint8Array([v & 0xFF, (v >> 8) & 0xFF]);
    const f32le = f => {
      const b = new ArrayBuffer(4);
      new DataView(b).setFloat32(0, Number(f) || 0, true);
      return new Uint8Array(b);
    };

    const CMD = {
      TARGET_ANGLE: 0x01, SET_CURRENT_MA: 0x02, SET_SPEED_LIMIT: 0x03, SET_PID: 0x04,
      SET_ID: 0x05, SET_MICROSTEPS: 0x06, SET_STEALTHCHOP: 0x07, SET_EXT_MODE: 0x08,
      SET_UNITS: 0x09, SET_ENC_INVERT: 0x0A, SET_ENABLED: 0x0B, SET_STEPS_PER_REV: 0x0C,
      DO_CALIBRATE: 0x0D, DO_HOMING: 0x0E, SET_ENDSTOP: 0x0F, SET_EXT_ENCODER: 0x10,
      SET_ACCEL_LIMIT: 0x11, SET_DIR_INVERT: 0x12,
      // EXT_SPI (0x13) REMOVED
      DO_AUTO_TUNE: 0x13,
      SET_LIMITSWITCH_ACTIVELOW: 0x14,
      TELEMETRY: 0x01, IMU_TELEMETRY: 0x02, IMU_SET_ID: 0xA1, RESET_ORIENT: 0xA2
    };

    const TUNESTATES = ["Idle", "Prep", "Fwd", "Bwd", "Inc", "Done"];

    const header = (id, cmd, len) => new Uint8Array([id & 0xFF, (id >> 8) & 0xFF, cmd, len]);

    const frame = {
      target: (id, val) => {
        const p = f32le(val);
        const h = header(id, CMD.TARGET_ANGLE, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      speed: (id, rps) => {
        const p = f32le(rps);
        const h = header(id, CMD.SET_SPEED_LIMIT, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      accel: (id, a) => {
        const p = f32le(a);
        const h = header(id, CMD.SET_ACCEL_LIMIT, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      current: (id, ma) => {
        const p = u16le(ma);
        const h = header(id, CMD.SET_CURRENT_MA, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      setId: (id, nid, isImu = false) => {
        const safe = clamp11(nid);
        const p = u16le(safe);
        const c = isImu ? CMD.IMU_SET_ID : CMD.SET_ID;
        const h = header(id, c, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      microsteps: (id, n) => {
        const p = u16le(n);
        const h = header(id, CMD.SET_MICROSTEPS, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      stepsPerRev: (id, n) => {
        const p = u16le(n);
        const h = header(id, CMD.SET_STEPS_PER_REV, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      bool1: (id, cmd, on) => {
        const p = u8(on ? 1 : 0);
        const h = header(id, cmd, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      pid: (id, kp, ki, kd) => {
        const p = new Uint8Array(12);
        p.set(f32le(kp), 0);
        p.set(f32le(ki), 4);
        p.set(f32le(kd), 8);
        const h = header(id, CMD.SET_PID, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      calibrate: (id) => header(id, CMD.DO_CALIBRATE, 0),
      resetOrient: (id) => header(id, CMD.RESET_ORIENT, 0),
      autoTune: (id, minA, maxA) => {
        const p = new Uint8Array(8);
        p.set(f32le(minA), 0);
        p.set(f32le(maxA), 4);
        const h = header(id, CMD.DO_AUTO_TUNE, p.length);
        const o = new Uint8Array(h.length + p.length);
        o.set(h, 0); o.set(p, h.length);
        return o;
      },
      home: (id, p) => {
        // useIN1(1), sensorless(1), cur(2), off(4), actLow(1), speed(4), dir(1) -> 14 bytes
        const b = new Uint8Array(14);
        let o = 0;
        // Logic: if sensorless, useIN1 is moot. 
        // Logic for wire: useIN1=1 if trigger active & !sensorless
        const useIn1 = (p.useIN1 && !p.sensorless) ? 1 : 0;
        const actLow = (p.activeLow && !p.sensorless) ? 1 : 0;

        b[o++] = useIn1;
        b[o++] = p.sensorless ? 1 : 0;
        b.set(u16le(p.cur), o); o += 2;
        b.set(f32le(p.off), o); o += 4;
        b[o++] = actLow;
        b.set(f32le(p.speed), o); o += 4;
        b[o++] = p.dir ? 1 : 0;

        const h = header(id, CMD.DO_HOMING, b.length);
        const out = new Uint8Array(h.length + b.length);
        out.set(h, 0); out.set(b, h.length);
        return out;
      }
    };

    /* STATE */
    const store = {
      devices: new Map(), // id -> {type, id, ...params}
      activeId: null,
      theme: 'dark'
    };

    const ICONS = {
      light: `<svg viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/></svg>`,
      dark: `<svg viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/></svg>`
    };

    function setTheme(mode) {
      store.theme = mode;
      const root = document.documentElement;
      if (mode === 'auto') root.removeAttribute('data-theme');
      else root.setAttribute('data-theme', mode);

      btnTheme.innerHTML = ICONS[mode];
      localStorage.setItem('tercio_theme', mode);
    }

    // Cycle: Light -> Dark
    btnTheme.onclick = () => {
      const next = (store.theme === 'dark') ? 'light' : 'dark';
      setTheme(next);
    };

    // Load saved theme
    (() => {
      const s = localStorage.getItem('tercio_theme');
      if (s) setTheme(s);
      else setTheme('dark');
    })();

    function logTx(u8) {
      // console.log("TX:", bytesHex(u8));
    }
    function logInfo(msg) {
      const div = document.createElement("div");
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
    }

    function setStatus(msg) {
      status.innerHTML = `<small>${msg}</small>`;
    }

    /* TELEMETRY PARSING */
    function parseTelemetryPayload(canArbId, u8arr) {
      // 37 is the size of AxisConfigWire packed.
      if (u8arr.length < 37) return null;
      const dv = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);

      let o = 0;
      o += 4; // crc32
      const microsteps = dv.getUint16(o, true); o += 2;
      const stepsPerRev = dv.getUint16(o, true); o += 2;
      const units = dv.getUint8(o); o += 1;
      const flags = dv.getUint16(o, true); o += 2;

      const encZeroCounts = dv.getUint16(o, true); o += 2;

      const currentmA = dv.getUint16(o, true); o += 2;
      const maxRPS = dv.getFloat32(o, true); o += 4;
      const maxRPS2 = dv.getFloat32(o, true); o += 4;
      const kp = dv.getFloat32(o, true); o += 4;
      const ki = dv.getFloat32(o, true); o += 4;
      const kd = dv.getFloat32(o, true); o += 4;
      const payloadCanId = dv.getUint16(o, true); o += 2;

      // Padding for float alignment (37 -> 40)
      while (o % 4 !== 0) o++;

      if (o + 20 > u8arr.length) return null;

      const speed = dv.getFloat32(o, true); o += 4;
      const angle = dv.getFloat32(o, true); o += 4;
      const target = dv.getFloat32(o, true); o += 4;
      const temp = dv.getFloat32(o, true); o += 4;
      const stalled = dv.getUint8(o) !== 0; o += 1;
      const tuneState = dv.getUint8(o); o += 1;
      const min = dv.getUint8(o) !== 0; o += 1;
      const max = dv.getUint8(o) !== 0; o += 1;

      // Extract flags
      // bit 0: encInvert
      // bit 1: dirInvert
      // bit 2: stealthChop
      // bit 3: externalMode
      // bit 4: enableEndStop
      // bit 5: externalEncoder
      // bit 6: calibratedOnce
      // bit 7: limitSwitchActiveLow (previously externalSPI)

      const cal = (flags & 0x40) !== 0;
      const activeLow = (flags & 0x80) !== 0; // New mapping

      return {
        id: payloadCanId, units, speed, angle, target, temp,
        stalled, tuneState, min, max, cal, flags, activeLow,
        microsteps, stepsPerRev, currentmA, maxRPS, maxRPS2, kp, ki, kd
      };
    }

    function parseImuTelemetry(canArbId, u8arr) {
      if (u8arr.length < 28) return null;
      const dv = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);

      const roll = dv.getFloat32(0, true);
      const pitch = dv.getFloat32(4, true);
      const yaw = dv.getFloat32(8, true);
      const ax = dv.getFloat32(12, true);
      const ay = dv.getFloat32(16, true);
      const az = dv.getFloat32(20, true);
      const temp = dv.getFloat32(24, true);

      if (!isFinite(roll) || !isFinite(pitch) || !isFinite(yaw)) return null;

      return { id: canArbId, roll, pitch, yaw, ax, ay, az, temp };
    }

    /* Web Serial */
    let port = null, reader = null, rxBuf = new Uint8Array(0);
    let writer = null, writeQueue = Promise.resolve();

    btnConnect.onclick = async () => {
      try {
        if (!('serial' in navigator)) { setStatus("Use Chrome/Edge."); return; }
        if (port) {
          try { if (writer) { await writer.close().catch(() => { }); } } catch (e) { }
          try { writer.releaseLock(); } catch (e) { }
          writer = null;
          reader?.releaseLock();
          await port.close();
          port = null;
          setStatus("Disconnected");
          btnConnect.textContent = "Connect";
          logInfo("Disconnected");
          return;
        }
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();

        setStatus("Connected");
        btnConnect.textContent = "Disconnect";
        logInfo("Connected");
        devSearch.value = ""; filterList();

        reader = port.readable.getReader();
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            appendBuf(value);
          }
        }
      } catch (e) {
        navigator.serial.addEventListener("disconnect", (e) => {
          if (e.port === port) btnConnect.click();
        });
        setStatus("Connect failed: " + (e?.message || e));
      }
    };

    async function sendBytes(u8arr) {
      if (!port || !writer) return;
      writeQueue = writeQueue.then(async () => {
        try {
          await writer.write(u8arr);
          logTx(u8arr);
        } catch (e) {
          const msg = String(e?.message || e);
          if (msg.includes("WritableStream is locked")) return;
          setStatus("Write failed: " + msg);
        }
      });
      return writeQueue;
    }

    function appendBuf(chunk) {
      const m = new Uint8Array(rxBuf.length + chunk.length);
      m.set(rxBuf, 0); m.set(chunk, rxBuf.length);
      rxBuf = m;
      processBuf();
    }

    function processBuf() {
      // Header: ID_LO(1), ID_HI(1), CMD(1), LEN(1) -> 4 bytes
      while (rxBuf.length >= 4) {
        const id = rxBuf[0] | (rxBuf[1] << 8);
        const cmd = rxBuf[2];
        const len = rxBuf[3];
        const total = 4 + len;
        if (rxBuf.length < total) return;

        const payload = rxBuf.subarray(4, 4 + len);

        if (cmd === CMD.TELEMETRY) {
          const p = parseTelemetryPayload(id, payload);
          if (p) {
            const prev = store.devices.get(p.id);
            const isNew = !store.devices.has(p.id);
            const prevTune = prev ? (prev.tuneState || 0) : 0;
            const tuneFinished = (p.tuneState === 5) && (prevTune !== 5) && (prevTune !== 0); // Done=5

            const st = { ...prev, type: 'motor', ...p, ts: Date.now() };
            store.devices.set(p.id, st);
            updateTile(p.id, st);

            if (store.activeId === p.id) {
              if (tuneFinished) {
                logInfo(`Auto-Tune complete for ID ${p.id}. Syncing UI.`);
                syncFormFromState(p.id, true);
              }
              renderActive();
              if (!tuneFinished) {
                // Soft sync
                syncFormFromState(p.id, false);
              }
            }

            if (store.activeId === null && isNew) {
              if (store.activeId === null) setActive(p.id);
            }

            if (store.activeId === p.id) {
              syncFormFromState(p.id, true);
              renderActive();
              renderTable();
              gate();
            }
          }
        }
        else if (cmd === CMD.IMU_TELEMETRY) {
          const imu = parseImuTelemetry(id, payload);
          if (imu) {
            const prev = store.devices.get(imu.id);
            const st = { ...prev, type: 'imu', ...imu, ts: Date.now() };
            store.devices.set(imu.id, st);
            updateTile(imu.id, st);

            if (store.activeId === null) setActive(imu.id);
            else if (store.activeId === imu.id) renderActive();
            renderTable();
            gate();
          }
        }

        rxBuf = rxBuf.subarray(total);
      }
    }

    /* Buttons & inputs */
    btnRefreshDevices.onclick = refreshListDevices;
    btnRefreshList.onclick = refreshListDevices;

    devSearch.addEventListener('input', filterList);
    inTarget.addEventListener('input', preview);

    function preview() {
      const v = parseFloat(inTarget.value);
      if (store.activeId == null) return;
      const st = store.devices.get(store.activeId);
      if (!st) return;
      const isDeg = (st.units === 1);
      $("preview").innerText = isNaN(v) ? "" : (v + (isDeg ? "°" : " rad"));
    }

    /* Motor Actions */
    btnSendTarget.onclick = () => {
      if (store.activeId == null) return;
      const val = parseFloat(inTarget.value);
      if (!isNaN(val)) sendBytes(frame.target(store.activeId, val));
    };
    btnSendLimits.onclick = () => {
      if (store.activeId == null) return;
      const s = parseFloat(inRps.value);
      const a = parseFloat(inRps2.value);
      if (!isNaN(s)) sendBytes(frame.speed(store.activeId, s));
      if (!isNaN(a)) sendBytes(frame.accel(store.activeId, a));
    };
    btnSetCurrent.onclick = () => {
      if (store.activeId == null) return;
      const m = parseInt(inmA.value);
      if (!isNaN(m)) sendBytes(frame.current(store.activeId, m));
    };
    btnCal.onclick = () => {
      if (store.activeId == null) return;
      if (confirm("Calibrate " + store.activeId + "? Motor will move.")) {
        sendBytes(frame.calibrate(store.activeId));
      }
    };
    tglEnable.onchange = () => {
      if (store.activeId == null) return;
      sendBytes(frame.bool1(store.activeId, CMD.SET_ENABLED, tglEnable.checked));
    };

    // Quick angles
    btn0.onclick = () => { inTarget.value = 0; btnSendTarget.click(); };
    btn90.onclick = () => {
      if (store.activeId == null) return;
      const st = store.devices.get(store.activeId);
      inTarget.value = (st && st.units === 1) ? 90 : 1.571;
      btnSendTarget.click();
    };
    btn180.onclick = () => {
      if (store.activeId == null) return;
      const st = store.devices.get(store.activeId);
      inTarget.value = (st && st.units === 1) ? 180 : 3.142;
      btnSendTarget.click();
    };

    /* Auto Tune */
    btnAutoTune.onclick = () => {
      if (store.activeId == null) return;
      const minA = parseFloat(inTuneMin.value);
      const maxA = parseFloat(inTuneMax.value);
      if (isNaN(minA) || isNaN(maxA)) return alert("Invalid angles");
      if (confirm(`Start Auto-Tune on ID ${store.activeId}? Motor will sweep.`)) {
        sendBytes(frame.autoTune(store.activeId, minA, maxA));
      }
    };

    /* Setup Tab */
    btnApplyID.onclick = () => {
      if (store.activeId == null) return;
      const nid = parseInt(newId.value);
      if (isNaN(nid)) return;
      const st = store.devices.get(store.activeId);
      if (confirm(`Change ID from ${store.activeId} to ${nid}?`)) {
        sendBytes(frame.setId(store.activeId, nid, st.type === 'imu'));
        // Clear old ID from local store after delay
        setTimeout(() => {
          store.devices.delete(store.activeId);
          setActive(nid);
        }, 500);
      }
    };
    btnApplyStepper.onclick = () => {
      if (store.activeId == null) return;
      const m = parseInt(ms.value);
      const s = parseInt(spr.value);
      if (!isNaN(m)) sendBytes(frame.microsteps(store.activeId, m));
      if (!isNaN(s)) sendBytes(frame.stepsPerRev(store.activeId, s));
    };

    /* Toggles */
    tglUnitsDeg.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_UNITS, tglUnitsDeg.checked));
    tglStealth.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_STEALTHCHOP, tglStealth.checked));
    tglExtMode.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_EXT_MODE, tglExtMode.checked));
    tglEncInvert.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_ENC_INVERT, tglEncInvert.checked));
    tglDirInvert.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_DIR_INVERT, tglDirInvert.checked));
    tglExtEnc.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_EXT_ENCODER, tglExtEnc.checked));
    tglEndstop.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_ENDSTOP, tglEndstop.checked));
    tglLimitActiveLow.onchange = () => sendBytes(frame.bool1(store.activeId, CMD.SET_LIMITSWITCH_ACTIVELOW, tglLimitActiveLow.checked));

    btnApplyPID.onclick = () => {
      if (store.activeId == null) return;
      const p = parseFloat(pidKp.value);
      const i = parseFloat(pidKi.value);
      const d = parseFloat(pidKd.value);
      if (!isNaN(p)) sendBytes(frame.pid(store.activeId, p, i, d));
    };

    /* Homing */
    // UX: handle toggle group
    const homeModeLimit = $("homeModeLimit");
    const homeModeSensorless = $("homeModeSensorless");
    const homeModeHint = $("homeModeHint");
    const homeCurrentWrap = $("homeCurrentWrap");
    const homeUseMinWrap = $("homeUseMinWrap");
    let homingSensorless = false;

    homeModeLimit.onclick = () => {
      homingSensorless = false;
      homeModeLimit.classList.add("active");
      homeModeLimit.setAttribute("aria-selected", "true");
      homeModeSensorless.classList.remove("active");
      homeModeSensorless.setAttribute("aria-selected", "false");
      homeModeHint.innerHTML = "Uses MIN/MAX endstop inputs. Configure <i>Active Low</i> in Modes & Flags.";
      homeCurrentWrap.style.display = 'none'; // hide current
      homeUseMinWrap.style.display = 'flex'; // show direction target
    };
    homeModeSensorless.onclick = () => {
      homingSensorless = true;
      homeModeSensorless.classList.add("active");
      homeModeSensorless.setAttribute("aria-selected", "true");
      homeModeLimit.classList.remove("active");
      homeModeLimit.setAttribute("aria-selected", "false");
      homeModeHint.innerHTML = "StallGuard based. <b>Requires Tuning.</b> Ensure 'Homing Current' is low enough to stall safely.";
      homeCurrentWrap.style.display = 'block'; // show current
      homeUseMinWrap.style.display = 'none'; // sensorless usually just runs one way? or both? 
      // Actually standard sensorless homing code provided earlier usually supports dir. 
      // But let's leave it visible if supported. 
      homeUseMinWrap.style.display = 'flex';
    };

    // Init state
    homeModeLimit.click();

    btnDoHome.onclick = () => {
      if (store.activeId == null) return;
      const off = parseFloat(homeOffset.value);
      const spd = parseFloat(homeSpeed.value);
      const cur = parseInt(homeCurrent.value);
      if (isNaN(off) || isNaN(spd)) return;

      const st = store.devices.get(store.activeId);
      const activeLow = st ? !!st.activeLow : true; // Use detected flag

      const params = {
        useIN1: homeUseMin.checked, // Seek to MIN?
        sensorless: homingSensorless,
        cur: isNaN(cur) ? 800 : cur,
        off: off,
        activeLow: activeLow,
        speed: spd,
        dir: homeDirPlus.checked
      };

      if (confirm(`Home ID ${store.activeId}? Ensure path is clear.`)) {
        sendBytes(frame.home(store.activeId, params));
      }
    };

    /* Bulk */
    btnSequential.onclick = async () => {
      if (!confirm("This will reassign IDs for ALL connected motors sequentially starting from " + bulkStart.value + ". Continue?")) return;
      let nextId = parseInt(bulkStart.value) || 1;
      // Heuristic: sort current IDs, then reassign one by one
      const ids = Array.from(store.devices.keys()).sort((a, b) => a - b);
      for (const oldId of ids) {
        if (store.devices.get(oldId).type === 'imu') continue; // Skip IMU
        await sendBytes(frame.setId(oldId, nextId, false));
        await new Promise(r => setTimeout(r, 100)); // gap
        nextId++;
      }
      setTimeout(refreshListDevices, 1000);
    };

    /* IMU Actions */
    btnImuZero.onclick = () => {
      if (store.activeId != null) sendBytes(frame.resetOrient(store.activeId));
    };

    /* Logging */
    btnClear.onclick = () => log.innerHTML = "";
    btnSave.onclick = () => {
      const blob = new Blob([log.innerText], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "tercio_log.txt";
      a.click();
    };

    btnExport.onclick = () => {
      // Export CSV of devices
      const rows = ["ID,Type,Angle,Speed,Temp,Stalled,Calibrated"];
      store.devices.forEach(d => {
        if (d.type === 'imu') {
          rows.push(`${d.id},IMU,${d.roll.toFixed(2)},-,${d.temp.toFixed(1)},-,-`);
        } else {
          rows.push(`${d.id},Motor,${d.angle.toFixed(2)},${d.speed.toFixed(2)},${d.temp.toFixed(1)},${d.stalled},${d.cal}`);
        }
      });
      const blob = new Blob([rows.join("\n")], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "devices.csv";
      a.click();
    };

    /* UI Logic */
    function refreshListDevices() {
      // Clear map if they want a full refresh? 
      // Actually, standard behavior is just keep receiving. 
      // But let's prune old ones (>5s)?
      const now = Date.now();
      for (const [id, d] of store.devices) {
        if (now - d.ts > 5000) store.devices.delete(id);
      }
      filterList();
    }

    function setActive(id) {
      store.activeId = id;
      document.querySelectorAll(".dev-item").forEach(el => {
        el.classList.toggle("active", parseInt(el.dataset.id) === id);
      });
      activeId.innerText = id;

      const st = store.devices.get(id);
      const isImu = st && st.type === 'imu';

      // Show/Hide controls
      if (isImu) {
        imuControls.classList.remove("hidden");
        motorControls.classList.add("hidden");
        imuTag.classList.remove("hidden");
        motorUnitsTag.classList.add("hidden");
        document.querySelectorAll(".motor-specific").forEach(el => el.classList.add("hidden"));

        // Hide calibration warnings for IMU
        calibWarn.classList.add("hidden");
        stallWarn.classList.add("hidden");

      } else {
        imuControls.classList.add("hidden");
        motorControls.classList.remove("hidden");
        imuTag.classList.add("hidden");
        motorUnitsTag.classList.remove("hidden");
        document.querySelectorAll(".motor-specific").forEach(el => el.classList.remove("hidden"));

        // Restore warnings for Motor
        if (st) {
          calibWarn.classList.toggle("hidden", !!st.cal);
          stallWarn.classList.toggle("hidden", !st.stalled);
        }
      }

      gate();
      syncFormFromState(id, true);
    }

    function gate() {
      const gatedEls = document.querySelectorAll('.gated input, .gated select, .gated button, .gated textarea');
      const st = store.devices.get(store.activeId);

      // No active device → everything disabled, hide banner
      if (!st) {
        gatedEls.forEach(el => el.disabled = true);
        calibWarn.classList.add('hidden');
        return;
      }

      // IMU device → no calibration concept
      if (st.type === 'imu') {
        gatedEls.forEach(el => el.disabled = true);
        calibWarn.classList.add('hidden');
        return;
      }

      // Motor device: use cal flag from latest telemetry
      const isCalibrated = !!st.cal;

      gatedEls.forEach(el => {
        el.disabled = !isCalibrated;
      });

      // Show warning ONLY when the active device is a motor and not calibrated
      calibWarn.classList.toggle('hidden', isCalibrated || store.activeId == null);
    }

    function syncFormFromState(id, hard = false) {
      const st = store.devices.get(id);
      if (!st) return;

      if (st.type === 'motor') {
        activeUnits.innerText = (st.units === 1) ? "deg" : "rad";
        targetUnits.innerText = (st.units === 1) ? "deg" : "rad";

        // Flags
        const flags = st.flags || 0;
        tglUnitsDeg.checked = (st.units === 1);
        tglStealth.checked = !!(flags & 0x04);
        tglExtMode.checked = !!(flags & 0x08);
        tglEndstop.checked = !!(flags & 0x10);
        tglExtEnc.checked = !!(flags & 0x20);

        tglEncInvert.checked = !!(flags & 0x01);
        tglDirInvert.checked = !!(flags & 0x02);

        // New ActiveLow mapping (bit 7)
        tglLimitActiveLow.checked = !!(flags & 0x80);

        if (hard) {
          // Fields that shouldn't auto-update while typing
          ms.value = st.microsteps;
          spr.value = st.stepsPerRev;
          inRps.value = st.maxRPS;
          inRps2.value = st.maxRPS2;
          pidKp.value = st.kp;
          pidKi.value = st.ki;
          pidKd.value = st.kd;
          inmA.value = st.currentmA;
        }

        stallWarn.classList.toggle("hidden", !st.stalled);
      }
    }

    function updateTile(id, st) {
      // Find or create
      let el = document.querySelector(`.dev-item[data-id='${id}']`);
      if (!el) {
        el = document.createElement("div");
        el.className = "dev-item";
        el.dataset.id = id;
        el.onclick = () => setActive(id);
        devList.appendChild(el);
      }

      const isImu = st.type === 'imu';
      const typeLabel = isImu ? "IMU" : "M";

      let badges = "";
      if (isImu) {
        badges = `<span class="tag" style="background:var(--purple);color:#fff">IMU</span>`;
      } else {
        if (st.stalled) badges += `<span class="tag warn">STALL</span>`;
        if (st.min) badges += `<span class=\"tag\">MIN</span>`;
        if (st.max) badges += `<span class=\"tag\">MAX</span>`;
        if (!st.cal) badges += `<span class=\"tag warn\">UNCAL</span>`;
      }

      let info = "";
      if (isImu) {
        info = `R:${st.roll.toFixed(1)} P:${st.pitch.toFixed(1)}`;
      } else {
        const u = (st.units === 1) ? "°" : "r";
        info = `${st.angle.toFixed(2)}${u} | ${st.temp.toFixed(0)}°C`;
      }

      el.innerHTML = `
        <div style="font-weight:bold; font-size:16px; width:30px; text-align:center">${id}</div>
        <div>
           <div class="dev-tags" style="margin-bottom:4px">${badges}</div>
           <div class="mono" style="font-size:13px; color:var(--muted)">${info}</div>
        </div>
        <div style="font-size:20px; color:var(--muted)">›</div>
      `;

      if (st.stalled) el.classList.add("stalled");
      else el.classList.remove("stalled");
    }

    function filterList() {
      const q = devSearch.value.toLowerCase();
      document.querySelectorAll(".dev-item").forEach(el => {
        const id = el.dataset.id;
        const st = store.devices.get(parseInt(id));
        const txt = (id + " " + (st ? JSON.stringify(st) : "")).toLowerCase();
        el.style.display = txt.includes(q) ? "grid" : "none";
      });
    }

    function renderActive() {
      const st = store.devices.get(store.activeId);
      if (!st) return;

      if (st.type === 'imu') {
        valRoll.innerText = st.roll.toFixed(2);
        valPitch.innerText = st.pitch.toFixed(2);
        valYaw.innerText = st.yaw.toFixed(2);
        valAx.innerText = st.ax.toFixed(2);
        valAy.innerText = st.ay.toFixed(2);
        valAz.innerText = st.az.toFixed(2);

        // 3D Cube
        const deg2rad = Math.PI / 180;
        // Simple mapping: Roll -> Z, Pitch -> X, Yaw -> Y for CSS transform?
        // Depends on frame. Let's try direct map.
        // CSS rotateX/Y/Z apply in order.
        imuCube.style.transform = `rotateX(${-st.pitch}deg) rotateY(${st.yaw}deg) rotateZ(${-st.roll}deg)`;

      } else {
        const u = (st.units === 1) ? "°" : "rad";
        tlmSpeed.innerText = st.speed.toFixed(2) + " rps";
        tlmAngle.innerText = st.angle.toFixed(2) + u;
        tlmTemp.innerText = st.temp.toFixed(1) + "°C";
        tlmStalled.innerText = st.stalled ? "YES" : "No";
        tlmStalled.style.color = st.stalled ? "var(--danger)" : "";
        tlmTune.innerText = TUNESTATES[st.tuneState] || st.tuneState;
        tlmMin.innerText = st.min ? "HIT" : "-";
        tlmMax.innerText = st.max ? "HIT" : "-";
        tlmCal.innerText = st.cal ? "OK" : "No";
        tlmCal.style.color = st.cal ? "var(--accent)" : "var(--warn)";
      }
    }

    // Auto-update table
    setInterval(renderTable, 500);

    function renderTable() {
      let html = "";
      // Sort by ID
      const ids = Array.from(store.devices.keys()).sort((a, b) => a - b);

      for (const id of ids) {
        const d = store.devices.get(id);
        const now = Date.now();
        const seen = ((now - d.ts) / 1000).toFixed(1) + "s";

        if (d.type === 'imu') {
          html += `<tr>
             <td class="mono"><b>${id}</b> <span class="tag" style="background:var(--purple);color:#fff">IMU</span></td>
             <td>-</td>
             <td>R: ${d.roll.toFixed(2)}</td>
             <td>P: ${d.pitch.toFixed(2)}</td>
             <td>Y: ${d.yaw.toFixed(2)}</td>
             <td>-</td>
             <td>-</td>
             <td>-</td>
             <td>-</td>
             <td>-</td>
             <td class="mono"><small>${seen}</small></td>
           </tr>`;
        } else {
          const u = d.units === 1 ? "deg" : "rad";
          const stallStyle = d.stalled ? "color:var(--danger);font-weight:bold" : "";
          const calStyle = d.cal ? "color:var(--accent)" : "color:var(--warn)";

          html += `<tr>
             <td class="mono"><b>${id}</b></td>
             <td>${u}</td>
             <td class="mono">${d.speed.toFixed(2)}</td>
             <td class="mono">${d.angle.toFixed(2)}</td>
             <td class="mono">${d.temp.toFixed(1)}</td>
             <td style="${stallStyle}">${d.stalled ? "YES" : "No"}</td>
             <td>${TUNESTATES[d.tuneState] || d.tuneState}</td>
             <td>${d.min ? "ON" : "-"}</td>
             <td>${d.max ? "ON" : "-"}</td>
             <td style="${calStyle}">${d.cal ? "Yes" : "No"}</td>
             <td class="mono"><small>${seen}</small></td>
           </tr>`;
        }
      }
      tblBodies.innerHTML = html;
    }

  </script>
</body>

</html>